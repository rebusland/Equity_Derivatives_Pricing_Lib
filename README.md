# Equity Pricer
A (hopefully) flexible, efficient and well-written *C++* implementation of an Equity derivatives pricer.  
Currently, the pricing engine only supports MonteCarlo simulations, but the overall implementation was designed
with the goal to provide, in the long run, a choice between three different pricing techniques: Montecarlo, Trees or analytical solutions/approximations (whenever possible).  
The pricing outputs currently evaluated are the fair price, the delta and the gamma Greeks.  
Referring to the MonteCarlo engine, estimates of price moments up to a specified degree could be returned: from the first and the second moment 
for instance, the MonteCarlo error could be inferred.  
A certain design effort was put to guarantee that the inclusion of new payoffs/products could be carried out seamlessly, without affecting
the rest of the architecture.

## MonteCarlo settings
Among the other settings:
 - Greeks calculation settings: e.g. the shift to be used while estimating the sensitivities.
 - Variance reduction technique: currently, only *Antithetic variates* is supported.
 - Number of simulations.
 - Seed.
 - Sequantial or Multithreaded (and if so, how many threads)?

## Calling the library
CMake will handle the build process, so that the *dll* or the *shared object* is produced.  
The file *SHARED_API.h* is the export header of the endpoints and it's generated automatically by CMake.  
The pricing endpoints are exposed to the outside world in the file *PricerAPI.h*,
in a way which is complaint to the *C* calling convention:
```cpp
extern "C" {

	const char* SHARED_API EvaluateBlack(
		const char* flatMktDataJSONString,
		const char* mcSettingsJSONString,
		const char* productJSONString
	);
	
	...
}
```
Only the API symbols are exported in the shared library, without name mangling.  
As in the example above, for each endpoint the more relevant inputs are: the derivative specifications, the market data and the pricing settings.  
IMPORTANT: Inputs/outputs serialized as JSONs: examples are provided in the project.  
###### Two usage ideas
The shared library could be called for instance from:
 - a script, e.g. a Python script using *ctypes*: this is how the author tested the library (soon the script will be shared).
 - a web service in Java, by means of a *JNI* layer: this would be the target way to call the library in the full end-to-end *concept* the author has in mind (GUI + backend + library).

## Third-party dependencies
#### RapidJSON
A fast JSON parser/generator for C++ from Tencent: https://rapidjson.org/  
**Advantages**: fast, "memory-friendly" and header-only

## Build instructions
The build process is managed through **CMake**. The building scripts generated by CMake (like Makefile for MINGW compiler
and Visual Studio file for MSVC compiler) as well as the target binaries, should be generated in the *build* folder.

The build folder can be specified in CMake with the *-B* option: for example, from the base folder we can state that the build outputs should be
placed in the *./build/Release* folder in the following way:  
```
cmake -Bbuild/Release <followed-by-other-commands> (NB no space after -B)
```

Single-target generators like MINGW can only manage a single build mode at a time: the chosen build mode (DEBUG, RELEASE, RELWITHINFO etc.)
can be specified by setting the CMake variable CMAKE_BUILD_TYPE; remember that multi-targets generators (like MSVC) automatically produce
the outputs for each build mode, therefore it's not necessary to set CMAKE_BUILD_TYPE.

It's recommended to create a sub-directory in the *./build* folder for each build mode (again DEBUG, RELEASE etc.) to get something like the following:  
```
Project-directory/
  Build/
	Debug/
	Release/
```

For each of these per-mode directories you can then issue commands to build with CMake, to compile with the generated scripts or to run the executables.
As an example, to build in Release mode and put all the build files into the *build/Release* folder, run the following:  
```
cmake -Bbuild/Release -DCMAKE_BUILD_TYPE=Release
```

Warning flags can be enabled or disabled my means of the option *_ENABLE_WARN*. For instance the compile warning flags could be set in a cmake build in this way:  
```
cmake -Bbuild/Release -DCMAKE_BUILD_TYPE=Release -D_ENABLE_WARN=ON
```

**Tip**: to run a generated Makefile script from the project folder without jumping into *./build/<some-other-path-where-Makefile-is-located>* you could use the -C option (run in project folder):  
```
make -C ./build/<some-other-path-where-Makefile-is-located> 
```

## TODOs
 - move here the high-level TODOs listed in the main classes
